# Leave Management System - SOLID and Clean Architecture

## Overview

Creating a **modular**, **testable** and **maintainable** application in **.NET Core** requires a solid foundation. Setting up an application architecture requires foresight and much consideration as early decisions will impact how easily the application is extended and maintained.

In the long run though, applications need to be maintained and in this case, extended. Between its design and the way the code was written, neither is really possible and so the application needs to be redesigned and future proofed.

## Why SOLID Architecture?

When we talk about **SOLID** architecture, we are referring to isnâ€™t a straightforward task. Decisions made early in the process can have a large impact later on, and maintainability and testability play an important role. Adopting these practices can also contribute to avoiding code smells, **refactoring code**, and **agile development**.

SOLID stands for:

    S - Single-Responsibility Principle

    O - Open-closed Principle

    L - Liskov Substitution Principle

    I - Interface Segregation Principle

    D - Dependency Inversion Principle

This Application uses:

    Clean or Onion Architecture and Best Practices

    Command Query Responsibility Segregation (CQRS)

    Mediatr Pattern

    Email Service using SendGrid

    Efficient Exception Handling and Routing

    Unit Testing

    Moq and Shouldy

    Global Error Handling with Custom Middleware and Exceptions

    Validation Using Fluent Validation

    .NET Core API and MVC UI Application

    JWT(JSON Web Token)  Authentication

